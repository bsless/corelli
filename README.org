* Corelli

  [[https://en.wikipedia.org/wiki/Arcangelo_Corelli][Arcangelo Corelli]]:
  
  #+begin_quote
  Arcangelo Corelli was an Italian violinist and composer of the Baroque era. 
  His music was key in the development of the modern genres of sonata and concerto, 
  in establishing the preeminence of the violin, 
  and as the first coalescing of modern tonality and functional harmony.
  #+end_quote

  This library is designed to compose simple core.async processes.
  It's probably suitable for micro-services.

  The configuration and data model are inspired by [[https://github.com/onyx-platform/onyx][Onyx]].
  
** Motivation
   
   There is usually little need to go through the logistics and ceremony, when
   using core.async, to manage the channels, puts and takes, and in most instances,
   lifecycle, as it naturally emerges from the topology.
   
   Processes' topologies are usually an emergent phenomenon and not explicitly stated.
   There is a mix between topology, business logic, and low level async apis.
   
   The idea is to separate the topology of the process from logic as much as 
   possible by providing a data language to describe the data flow, and functions
   and other vars are to be resolved when "compiling" the model.
   
** Data Model

   - Edges: core.async channels
   - Vertices: processing units, connected by channels. Can be pipes, drivers, sinks.

   The graph is describe in terms of two collections:

   - Edges: data describing only the channels, including buffer types, buffer functions, size and transducers.
   - Nodes: data describing a pipeline between two channels, mult, producer or consumer.

   Both are defined in terms of specs, using ~clojure.spec.alpha~, which is 
   the source of truth, but can generally look like so:
   
   #+begin_src clojure
     ;;; edge
     {::name :input-chan
      ::buffer :clojure.core.async/buffer
      ::size 1
      ::xf :cat}

     ;;; node
     {::name :parse
      ::from :input-chan
      ::to :send-chan
      ::xf :parse-json}
   #+end_src

   
*** Buffers
    
    #+begin_src clojure
      {:buffer/type :buffer.type/blocking
       :buffer/size 8}

      {:buffer/type :buffer.type/sliding
       :buffer/size 8}

      {:buffer/type :buffer.type/dropping
       :buffer/size 8}
    #+end_src
    
*** Channels

    #+begin_src clojure
      {:chan/name :a
       :chan/type :chan.type/simple}

      {:chan/name :b
       :chan/type :chan.type/sized
       :chan/size 8}

      {:chan/name :c
       :chan/type :chan.type/buffered
       :chan/buffer {:buffer/type :buffer.type/blocking
                     :buffer/size 8}}
    #+end_src
    
** Extension

*** Buffers

    #+begin_src clojure
      (defmethod buffer-type :buffer.type/your-new-type [_] ::spec-for-your-type)

      (defmethod compile-buffer :buffer.type/your-new-type
        [{:keys [:buffer/arg1 :buffer/arg2]}]
        (your-buffer-fn arg1 arg2))
    #+end_src
    
*** Channels

    #+begin_src clojure
      (defmethod chan-type :chan.type/your-new-type [_] ::spec-for-your-type)

      (defmethod compile-chan :chan.type/your-new-type
        [{:keys [:chan/arg1 :chan/arg2]}]
        (your-chan-fn arg1 arg2))
    #+end_src

** Usage

   - Define correct sequences of edges and nodes (can be verified using spec).
   - Define the required vars.
   - Try compiling the model using ~compile-topology~.

** Status
   
   Highly experimental. Not even tested yet. Don't use it.

** Roadmap
   
   - [ ] Rework channel representation
   - [ ] qualify different specs
   - [ ] replace ~cond~ with multimethod.
   - [ ] Tests
   - [ ] Analyze the topology to find any dangling channels or disconnected pipes before instancing the pipes.
   - [ ] Implement ~select~ based on ~alt!~ and/or ~alts!~.
   - [ ] Find an idiomatic way to connect a web handler as driver.
   - [ ] plugin / extension system.
   - [ ] Refine specs, currently have no way to differentiate transducers from regular functions.
